<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é£›ã³ç«‹ã¦ï¼æœªæ¥ã®ç©ºã¸ï¼</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #ADD8E6; /* è–„ã„æ°´è‰² */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            position: relative;
            /* é£›è¡Œæ©Ÿã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚’èƒŒæ™¯ã«ç¹°ã‚Šè¿”ã—è¡¨ç¤º */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAhUlEQVQ4T2NkYGBg+M+ACUc+IwgcwAhFAzEwMDg0MDAwNgZGBgYGYwMDEwMYAImAgYQoQFIUgCjhCAQowGQoQAYkUAUkwFQQgJhUgEwpgMQpQCI0oAEQpAERZgAQAo4m40xhlSUAAAAASUVORK5CYII=');
            background-repeat: repeat;
        }
        canvas {
            border: 2px solid #333;
            background-color: #87CEEB; /* ç©ºã®ã‚¤ãƒ¡ãƒ¼ã‚¸ */
            display: block;
            max-width: 100%;
            height: auto;
        }
        #message-overlay, #rules-overlay {
            position: fixed; /* absolute ã‹ã‚‰ fixed ã«å¤‰æ›´ã—ã¦ã€å¸¸ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå…¨ä½“ã‚’è¦†ã†ã‚ˆã†ã« */
            top: 0;
            left: 0;
            width: 100vw; /* å¸¸ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®å¹… */
            height: 100vh; /* å¸¸ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®é«˜ã• */
            background-color: rgba(0, 0, 0, 0.9); /* ã•ã‚‰ã«ä¸é€æ˜åº¦ã‚’ä¸Šã’ã¦ã€ä¸‹ã®è¦ç´ ã‚’éš ã™ */
            color: white;
            display: flex;
            justify-content: center; /* ä¸­å¤®æƒãˆ */
            align-items: center;     /* ä¸­å¤®æƒãˆ */
            flex-direction: column;
            text-align: center;
            display: none;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }
        #rules-overlay > div { /* ãƒ«ãƒ¼ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å›²ã‚€æ–°ã—ã„divã‚’è¿½åŠ ï¼ˆä¸­å¤®å¯„ã›ç”¨ï¼‰ */
            max-width: 700px;
            width: 90%; /* ç”»é¢å¹…ã®90%ã‚’æœ€å¤§ã« */
            background-color: rgba(0, 0, 0, 0.8); /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®èƒŒæ™¯è‰²ã‚’å°‘ã—æ˜ã‚‹ã */
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            text-align: left; /* ãƒ†ã‚­ã‚¹ãƒˆã‚’å·¦å¯„ã›ã« */
            overflow-y: auto; /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã¯ã¿å‡ºã—ãŸã‚‰ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã« */
            max-height: 90vh; /* ç”»é¢é«˜ã®90%ã‚’æœ€å¤§ã« */
        }
        #rules-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            color: #FFD700;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        #rules-overlay h3 {
            font-size: 1.8em;
            margin-top: 25px;
            margin-bottom: 15px;
            color: #ADD8E6;
            text-align: center;
        }
        #rules-overlay p, #rules-overlay ul, #rules-overlay ol {
            margin-bottom: 15px;
            padding: 0 20px;
            text-align: left;
        }
        #rules-overlay li {
            margin-bottom: 8px;
        }
        #rules-overlay strong {
            color: #FFECB3;
        }
        #message-overlay button, #rules-overlay button {
            font-size: 1.6em;
            padding: 12px 25px;
            margin-top: 30px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #message-overlay button:hover, #rules-overlay button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        #message-overlay button:active, #rules-overlay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #timer-display, #landing-guide {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #333;
            font-size: 1.5em;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
            line-height: 1.4;
            z-index: 20;
        }
        #landing-guide {
            top: 10px;
            right: 10px;
            left: auto;
            text-align: left;
        }
        #game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: pink;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 50;
            pointer-events: none;
            white-space: nowrap;
        }

        /* ã‚²ãƒ¼ãƒ ä¸­ãƒ«ãƒ¼ãƒ«ç¢ºèªãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #show-rules-button {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 1.2em;
            padding: 8px 15px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #6495ED;
            color: white;
            z-index: 110;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, transform 0.1s;
        }
        #show-rules-button:hover {
            background-color: #558BEF;
            transform: translateY(-1px);
        }
        #show-rules-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }


        /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ç”¨æ“ä½œãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .controls-container {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 60;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .control-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1.8em;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            opacity: 0.8;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .control-button:active {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .horizontal-controls {
            display: flex;
            gap: 10px;
        }

        .vertical-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* ç”»é¢å·¦å³ã®ä»®æƒ³ãƒœã‚¿ãƒ³é ˜åŸŸ */
        .touch-area {
            position: absolute;
            top: 0;
            height: 100%;
            width: 25%;
            z-index: 10;
        }

        #left-touch-area {
            left: 0;
        }

        #right-touch-area {
            right: 0;
        }

        /* ã‚¹ãƒãƒ›ã§ã®è¡¨ç¤ºã‚’èª¿æ•´ */
        @media (max-width: 768px) {
            #game-title {
                font-size: 1.8em;
            }
            #message-overlay {
                font-size: 2.5em;
            }
            #message-overlay button {
                font-size: 1.2em;
                padding: 8px 15px;
            }
            #rules-overlay > div { /* ã‚¹ãƒãƒ›å‘ã‘èª¿æ•´ */
                font-size: 0.9em;
                padding: 15px;
                width: 95%; /* ã‚ˆã‚Šç”»é¢ã„ã£ã±ã„ã« */
                max-height: 95vh;
            }
            #rules-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            #rules-overlay h3 {
                font-size: 1.3em;
                margin-top: 15px;
                margin-bottom: 10px;
            }
            #rules-overlay p, #rules-overlay ul, #rules-overlay ol {
                padding: 0 10px;
            }
            #rules-overlay button {
                font-size: 1.2em;
                padding: 10px 20px;
                margin-top: 20px;
            }
            #timer-display, #landing-guide {
                font-size: 1em;
                padding: 3px 6px;
            }
            #show-rules-button {
                font-size: 1em;
                padding: 6px 12px;
                top: 40px;
            }
            .control-button {
                padding: 10px 15px;
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="game-title">é£›ã³ç«‹ã¦ï¼æœªæ¥ã®ç©ºã¸ï¼</div>
    <div id="timer-display"></div>
    <button id="show-rules-button">ãƒ«ãƒ¼ãƒ«</button>
    <div id="landing-guide"></div>

    <div class="controls-container">
        <div class="horizontal-controls">
            <button id="left-button" class="control-button">â†</button>
            <button id="right-button" class="control-button">â†’</button>
        </div>
        <div class="vertical-controls">
            <button id="up-button" class="control-button">â†‘</button>
            <button id="down-button" class="control-button">â†“</button>
        </div>
    </div>

    <div id="left-touch-area" class="touch-area"></div>
    <div id="right-touch-area" class="touch-area"></div>

    <div id="message-overlay">
        <span id="game-status-message"></span>
        <button id="restart-button">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>

    <div id="rules-overlay">
        <div> <h2>âœˆï¸ æœªæ¥ã®ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã‚ˆã€æº–å‚™ã¯ã„ã„ã‹ï¼Ÿ âœˆï¸</h2>
            <p>
                ã“ã®ã‚²ãƒ¼ãƒ ã¯ã€å›ã®æ“ç¸¦ã‚¹ã‚­ãƒ«ãŒè©¦ã•ã‚Œã‚‹ã€ã‚¹ãƒªãƒªãƒ³ã‚°ãªãƒ•ãƒ©ã‚¤ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã ï¼<br>
                å¤§ç©ºã‚’é§†ã‘å·¡ã‚Šã€ç„¡äº‹ã«ç€é™¸ã§ãã‚‹ã‹æŒ‘æˆ¦ã—ã‚ˆã†ï¼
            </p>
            <h3>ğŸš€ æ“ä½œæ–¹æ³•</h3>
            <ul>
                <li><strong>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰:</strong> çŸ¢å°ã‚­ãƒ¼ (â†‘ ä¸Šæ˜‡, â†“ ä¸‹é™, â† å·¦ç§»å‹•, â†’ å³ç§»å‹•)</li>
                <li><strong>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³:</strong> ç”»é¢ä¸‹ã®æ“ä½œãƒœã‚¿ãƒ³ã€ã¾ãŸã¯ç”»é¢å·¦å³ã®ä»®æƒ³ã‚¿ãƒƒãƒã‚¨ãƒªã‚¢ã‚’ã‚¿ãƒƒãƒ—ï¼</li>
            </ul>
            <h3>ğŸ® ã‚²ãƒ¼ãƒ ã®æµã‚Œ</h3>
            <ol>
                <li><strong>é›¢é™¸æº–å‚™ & è¨±å¯:</strong> ç®¡åˆ¶å¡”ã‹ã‚‰ã®æŒ‡ç¤ºã‚’å¾…ã¨ã†ï¼</li>
                <li><strong>å¤§ç©ºã¸ãƒ†ã‚¤ã‚¯ã‚ªãƒ•ï¼:</strong> åœ°ä¸Šã§ååˆ†ã«åŠ é€Ÿã—ãŸã‚‰ã€æ©Ÿé¦–ã‚’ä¸Šã’ã¦é›¢é™¸ã ï¼</li>
                <li><strong>ãƒ•ãƒ©ã‚¤ãƒˆã‚¿ã‚¤ãƒ  (20ç§’):</strong> é›²ã®ä¸Šã‚’è‡ªç”±ã«é£›è¡Œï¼ãŸã ã—ã€ä»–ã®é£›è¡Œæ©Ÿã¨ã®è¡çªã«ã¯è¦æ³¨æ„ï¼</li>
                <li><strong>ç€é™¸è¨±å¯ & ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong> é£›è¡Œæ™‚é–“ãŒçµ‚ã‚ã‚‹ã¨ã€ç€é™¸ã®æŒ‡ç¤ºãŒæ¥ã‚‹ãã€‚</li>
                <li><strong>å®‰å…¨ã«ç€é™¸ï¼:</strong> æ»‘èµ°è·¯ã‚’ç›®æŒ‡ã—ã¦ã€æ…é‡ã«é«˜åº¦ã¨é€Ÿåº¦ã‚’èª¿æ•´ã ï¼ç‰¹ã«ã€æ¥åœ°æ™‚ã®ã€Œå‚ç›´é€Ÿåº¦ã€ã‚’ã‚†ã£ãã‚Šã«ã€ãã—ã¦ã€Œæ»‘èµ°è·¯ã®çœŸã‚“ä¸­ã€ã«ç€åœ°ã§ãã‚Œã°å¤§æˆåŠŸï¼</li>
            </ol>
            <p>ã•ã‚ã€å›ã®ãƒ•ãƒ©ã‚¤ãƒˆãŒå§‹ã¾ã‚‹ï¼å®‰å…¨ãªç€é™¸ã‚’ç›®æŒ‡ã—ã¦ã€æœ€é«˜ã®ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã«ãªã‚ã†ï¼</p>
            <button id="start-game-button">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageOverlay = document.getElementById('message-overlay');
        const gameStatusMessage = document.getElementById('game-status-message');
        const restartButton = document.getElementById('restart-button');
        const timerDisplay = document.getElementById('timer-display');
        const landingGuide = document.getElementById('landing-guide');
        const gameTitleDisplay = document.getElementById('game-title');

        // ãƒ«ãƒ¼ãƒ«èª¬æ˜é–¢é€£è¦ç´ 
        const rulesOverlay = document.getElementById('rules-overlay');
        const startGameButton = document.getElementById('start-game-button');

        // ã‚²ãƒ¼ãƒ ä¸­ãƒ«ãƒ¼ãƒ«ç¢ºèªãƒœã‚¿ãƒ³
        const showRulesButton = document.getElementById('show-rules-button');

        // ã‚¹ãƒãƒ›æ“ä½œãƒœã‚¿ãƒ³è¦ç´ 
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const controlsContainer = document.querySelector('.controls-container');

        // ä»®æƒ³ã‚¿ãƒƒãƒã‚¨ãƒªã‚¢è¦ç´ 
        const leftTouchArea = document.getElementById('left-touch-area');
        const rightTouchArea = document.getElementById('right-touch-area');

        // éŸ³å£°èª­ã¿ä¸Šã’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æº–å‚™
        const synth = window.speechSynthesis;
        const utterance = new SpeechSynthesisUtterance();
        utterance.lang = 'en-US'; // è‹±èªã§èª­ã¿ä¸Šã’ï¼ˆç®¡åˆ¶å¡”ã®é›°å›²æ°—ï¼‰
        utterance.volume = 1;     // éŸ³é‡
        utterance.rate = 1.0;     // é€Ÿåº¦
        utterance.pitch = 1.0;    // ãƒ”ãƒƒãƒ

        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
        let gameActive = false; // åˆæœŸçŠ¶æ…‹ã§ã¯æ“ä½œä¸å¯

        // ã‚²ãƒ¼ãƒ ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†
        const GAME_PHASE = {
            RULES_EXPLANATION: 0, // æ–°ã—ã„ãƒ•ã‚§ãƒ¼ã‚º
            TAKEOFF_CLEARANCE: 1,
            FLIGHT: 2,
            LANDING_CLEARANCE: 3,
            LANDING: 4,
            GAME_OVER: 5,
            GAME_CLEAR: 6
        };
        let currentPhase = GAME_PHASE.RULES_EXPLANATION; // åˆæœŸãƒ•ã‚§ãƒ¼ã‚ºã‚’ãƒ«ãƒ¼ãƒ«èª¬æ˜ã«è¨­å®š

        // é›¢é™¸è¨±å¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é–¢é€£
        let showTakeOffClearance = true;
        const takeOffClearanceDuration = 3000; // 3ç§’é–“è¡¨ç¤º
        let takeOffClearanceStartTime;
        let takeOffClearanceSpoken = false; // èª­ã¿ä¸Šã’æ¸ˆã¿ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

        // é£›è¡Œãƒ•ã‚§ãƒ¼ã‚ºã®ã‚¿ã‚¤ãƒãƒ¼
        let flightTimeElapsed = 0;
        const flightDurationRequired = 20 * 1000; // é£›è¡Œæ™‚é–“ç›®æ¨™ã‚’20ç§’ã«å»¶é•·

        // ç€é™¸è¨±å¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é–¢é€£
        let showLandingClearance = false;
        const landingClearanceDuration = 5000; // 5ç§’é–“è¡¨ç¤º
        let landingClearanceStartTime;
        let landingClearanceSpoken = false; // èª­ã¿ä¸Šã’æ¸ˆã¿ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

        // é£›è¡Œæ©Ÿã®åˆæœŸè¨­å®š (åŸå¯¸å¤§ã®æ¯”ç‡ã§åˆæœŸåŒ–)
        const initialCanvasWidth = 800;
        const initialCanvasHeight = 600;
        let planeX = initialCanvasWidth / 2;
        let planeY = initialCanvasHeight - 50;
        const planeWidth = 60;
        const planeHeight = 40;
        let planeSpeedX = 0;
        let planeSpeedY = 0;
        const acceleration = 0.2;
        const gravity = 0.1;
        const lift = -0.5;
        const maxGroundSpeed = 5;
        const maxAirSpeedY = 8; // æœ€å¤§ä¸Šæ˜‡ãƒ»ä¸‹é™é€Ÿåº¦
        let isInAir = false;
        const airportDisappearAltitude = initialCanvasHeight - 200; // ã“ã®é«˜åº¦ã‚’è¶…ãˆã‚‹ã¨ç©ºæ¸¯ãŒæ¶ˆãˆã‚‹
        const airportReappearAltitude = initialCanvasHeight - 100; // ã“ã®é«˜åº¦ã‚’ä¸‹å›ã‚‹ã¨ç©ºæ¸¯ãŒå‡ºç¾

        // æ»‘èµ°è·¯ã®è¨­å®š (åŸå¯¸å¤§ã®æ¯”ç‡ã§åˆæœŸåŒ–)
        const runwayHeight = 80;
        let runwayY = initialCanvasHeight - runwayHeight;
        const runwayColor = '#808080';
        const runwayLineColor = '#FFF';
        const runwayLineWidth = 5;

        // ç©ºæ¸¯æ–½è¨­ã®è¨­å®š (åŸå¯¸å¤§ã®æ¯”ç‡ã§åˆæœŸåŒ–)
        const terminalWidth = 150;
        const terminalHeight = 80;
        const terminalColor = '#A9A9A9';

        const controlTowerWidth = 20;
        const controlTowerHeight = 100;
        const controlTowerColor = '#696969';
        let controlTowerX = initialCanvasWidth / 2 + 100 + 150 / 2 + 20 + controlTowerWidth / 2;
        let controlTowerY = runwayY + runwayHeight - terminalHeight - controlTowerHeight - 20;

        const apronColor = '#606060';
        const apronWidth = 300;
        const apronHeight = 100;

        // é›²ã®è¨­å®š
        const clouds = [];
        const maxClouds = 10;
        const cloudSpeed = 1;

        // ä»–ã®é£›è¡Œæ©Ÿã®è¨­å®š
        const otherPlanes = [];
        const maxOtherPlanes = 3;
        const otherPlaneSpeedMin = 2;
        const otherPlaneSpeedMax = 4;
        const otherPlaneSpawnInterval = 300;
        let otherPlaneSpawnTimer = 0;

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨ã‚¿ãƒƒãƒã®çŠ¶æ…‹ã‚’çµ±åˆç®¡ç†
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            // ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ã®çŠ¶æ…‹
            UpButton: false,
            DownButton: false,
            LeftButton: false,
            RightButton: false
        };

        // ç€é™¸æˆåŠŸæ¡ä»¶ã®é–¾å€¤ï¼ˆå¤§å¹…ã«ç·©å’Œï¼‰
        const targetVerticalSpeed = 5; // çµ¶å¯¾å€¤5æœªæº€ã«ç·©å’Œ
        const landingAltitudeTolerance = 20; // æ»‘èµ°è·¯ã®é«˜ã•ã‹ã‚‰ä¸Šä¸‹20pxä»¥å†…ã§ã‚ã‚Œã°OK
        let targetLandingAltitude = runwayY - planeHeight / 2; // åœ°é¢ã«æ¥ã™ã‚‹Yåº§æ¨™

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚ºå‡¦ç†
        function resizeCanvas() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦å†…éƒ¨è§£åƒåº¦ã‚’è¨­å®š
            let aspectRatio = initialCanvasWidth / initialCanvasHeight;
            let newWidth, newHeight;

            if (displayWidth / displayHeight > aspectRatio) {
                newHeight = displayHeight;
                newWidth = displayHeight * aspectRatio;
            } else {
                newWidth = displayWidth;
                newHeight = displayWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // ã‚²ãƒ¼ãƒ è¦ç´ ã®åº§æ¨™ã‚’æ–°ã—ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒ«
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // å›ºå®šè¦ç´ ã®Yåº§æ¨™ã‚’å†è¨ˆç®—
            runwayY = canvas.height - runwayHeight * scaleY;
            targetLandingAltitude = runwayY - planeHeight * scaleY / 2; // ç€é™¸ç›®æ¨™é«˜åº¦ã‚‚ã‚¹ã‚±ãƒ¼ãƒ«
            controlTowerX = (initialCanvasWidth / 2 + 100 + 150 / 2 + 20 + controlTowerWidth / 2) * scaleX;
            controlTowerY = runwayY + runwayHeight * scaleY - terminalHeight * scaleY - controlTowerHeight * scaleY - 20 * scaleY;
        }

        // éŸ³å£°èª­ã¿ä¸Šã’é–¢æ•°
        function speakMessage(message) {
            if (synth.speaking) {
                synth.cancel(); // æ—¢ã«èª­ã¿ä¸Šã’ä¸­ã®å ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            }
            utterance.text = message;
            synth.speak(utterance);
        }

        // ã‚²ãƒ¼ãƒ ã®ãƒªã‚»ãƒƒãƒˆé–¢æ•°
        function resetGame() {
            // åˆæœŸè¨­å®šå€¤ã«åŸºã¥ã„ã¦ãƒªã‚»ãƒƒãƒˆ
            planeX = initialCanvasWidth / 2;
            planeY = initialCanvasHeight - 50;
            planeSpeedX = 0;
            planeSpeedY = 0;
            isInAir = false;
            gameActive = false;
            clouds.length = 0;
            otherPlanes.length = 0;
            otherPlaneSpawnTimer = 0;
            flightTimeElapsed = 0;
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';

            messageOverlay.style.display = 'none';

            showTakeOffClearance = true;
            takeOffClearanceSpoken = false;
            showLandingClearance = false;
            landingClearanceSpoken = false;

            currentPhase = GAME_PHASE.RULES_EXPLANATION; // ãƒªã‚»ãƒƒãƒˆæ™‚ã‚‚ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‹ã‚‰é–‹å§‹
            showRulesExplanation(); // ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚’è¡¨ç¤º
            hideControls(); // æ“ä½œãƒœã‚¿ãƒ³ã‚’éš ã™
            showRulesButton.style.display = 'none'; // ãƒªã‚»ãƒƒãƒˆæ™‚ã¯ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
        }

        // æ“ä½œãƒœã‚¿ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹é–¢æ•°
        function showControls() {
            controlsContainer.style.display = 'flex';
            leftTouchArea.style.display = 'block';
            rightTouchArea.style.display = 'block';
        }

        function hideControls() {
            controlsContainer.style.display = 'none';
            leftTouchArea.style.display = 'none';
            rightTouchArea.style.display = 'none';
        }

        // ãƒ«ãƒ¼ãƒ«èª¬æ˜ã®è¡¨ç¤º/éè¡¨ç¤º
        function showRulesExplanation() {
            rulesOverlay.style.display = 'flex';
            gameTitleDisplay.style.display = 'block'; // ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¡¨ç¤º
            canvas.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            showRulesButton.style.display = 'none'; // ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºä¸­ã¯ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            timerDisplay.style.display = 'none'; // ã‚¿ã‚¤ãƒãƒ¼ã‚’éè¡¨ç¤º
            landingGuide.style.display = 'none'; // ç€é™¸ã‚¬ã‚¤ãƒ‰ã‚’éè¡¨ç¤º
            hideControls(); // æ“ä½œãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            gameActive = false; // ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºä¸­ã¯ã‚²ãƒ¼ãƒ ã‚’ä¸€æ™‚åœæ­¢
        }

        function hideRulesExplanation() {
            rulesOverlay.style.display = 'none';
            gameTitleDisplay.style.display = 'none'; // ã‚¿ã‚¤ãƒˆãƒ«ã‚’éš ã™
            canvas.style.display = 'block'; // ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è¡¨ç¤ºã™ã‚‹
            // ã‚²ãƒ¼ãƒ ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã¾ãŸã¯ç‰¹å®šã®ãƒ•ã‚§ãƒ¼ã‚ºã®å ´åˆã¯ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (currentPhase !== GAME_PHASE.RULES_EXPLANATION &&
                currentPhase !== GAME_PHASE.GAME_OVER &&
                currentPhase !== GAME_PHASE.GAME_CLEAR) {
                showRulesButton.style.display = 'block';
            }
            // å„ãƒ•ã‚§ãƒ¼ã‚ºã«å¿œã˜ã¦UIè¦ç´ ã‚’å†è¡¨ç¤º
            if (currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE) {
                // TAKEOFF_CLEARANCEã¯ã‚²ãƒ¼ãƒ Activeã§ã¯ãªã„ãŒã€æ“ä½œãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ãŸã„
                showControls();
            } else if (currentPhase === GAME_PHASE.FLIGHT) {
                showControls();
                timerDisplay.style.display = 'block';
                gameActive = true; // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
            } else if (currentPhase === GAME_PHASE.LANDING_CLEARANCE) {
                showControls();
            } else if (currentPhase === GAME_PHASE.LANDING) {
                showControls();
                landingGuide.style.display = 'block';
                gameActive = true; // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
            }
        }

        /**
         * æ»‘èµ°è·¯ã‚’æç”»ã™ã‚‹é–¢æ•°
         * ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦æç”»
         */
        function drawRunway() {
            const scaleY = canvas.height / initialCanvasHeight;
            const scaledRunwayY = canvas.height - runwayHeight * scaleY;
            const scaledRunwayHeight = runwayHeight * scaleY;
            
            ctx.fillStyle = runwayColor;
            ctx.fillRect(0, scaledRunwayY, canvas.width, scaledRunwayHeight);
            
            // æ»‘èµ°è·¯ã®ä¸­å¿ƒç·š (ç™½ã„ç‚¹ç·š)
            ctx.strokeStyle = runwayLineColor;
            ctx.lineWidth = 4 * scaleY; // ç·šå¹…ã‚’å°‘ã—å¤ªãã™ã‚‹
            ctx.setLineDash([2 * (canvas.width / initialCanvasWidth), 20 * (canvas.width / initialCanvasWidth)]); // çŸ­ã„ç·šã¨é•·ã‚ã®é–“éš”ã§ç‚¹ç·šé¢¨
            ctx.beginPath();
            ctx.moveTo(0, scaledRunwayY + scaledRunwayHeight / 2);
            ctx.lineTo(canvas.width, scaledRunwayY + scaledRunwayHeight / 2);
            ctx.stroke();
            ctx.setLineDash([]); // ç·šãƒ€ãƒƒã‚·ãƒ¥ã‚’ãƒªã‚»ãƒƒãƒˆ (ä»–ã®æç”»ã«å½±éŸ¿ã‚’ä¸ãˆãªã„ã‚ˆã†ã«)

            // æ»‘èµ°è·¯ã®å¢ƒç•Œç·š (ç™½ã„å®Ÿç·š)
            ctx.strokeStyle = runwayLineColor;
            ctx.lineWidth = 5 * scaleY; // ç·šå¹…ã‚’èª¿æ•´
            ctx.beginPath();
            ctx.moveTo(0, scaledRunwayY);
            ctx.lineTo(canvas.width, scaledRunwayY);
            ctx.moveTo(0, scaledRunwayY + scaledRunwayHeight);
            ctx.lineTo(canvas.width, scaledRunwayY + scaledRunwayHeight);
            ctx.stroke();
        }
         function drawRunway() {
             ctx.fillStyle = runwayColor;
             ctx.fillRect(0, runwayY, canvas.width, runwayHeight);
 
             // æ»‘èµ°è·¯ã®ãƒ©ã‚¤ãƒ³ã‚’æç”»
             ctx.strokeStyle = runwayLineColor;
             ctx.lineWidth = runwayLineWidth;
             const lineDashLength = 20;
             const lineGapLength = 30;
             const numDashes = canvas.width / (lineDashLength + lineGapLength);
             ctx.beginPath();
             for (let i = 0; i < numDashes; i++) {
                 const startX = i * (lineDashLength + lineGapLength);
                 ctx.moveTo(startX, runwayY + runwayHeight / 2);
                 ctx.lineTo(startX + lineDashLength, runwayY + runwayHeight / 2);
             }
             ctx.stroke();
         }
        /**
         * ç©ºæ¸¯æ–½è¨­ã‚’æç”»ã™ã‚‹é–¢æ•°
         * ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦æç”»
         */
        function drawAirport() {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // åœ°é¢
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(0, runwayY, canvas.width, canvas.height - runwayY);

            // é§æ©Ÿå ´ (ã‚¨ãƒ—ãƒ­ãƒ³)
            ctx.fillStyle = apronColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY), apronWidth * scaleX, apronHeight * scaleY);
            ctx.fillRect((initialCanvasWidth / 2 - 400) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY), apronWidth * scaleX, apronHeight * scaleY);

            // èª˜å°è·¯ (æ»‘èµ°è·¯ã¨é§æ©Ÿå ´ã‚’ã¤ãªã)
            ctx.fillStyle = apronColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100) * scaleX, runwayY + runwayHeight * scaleY - 20 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect((initialCanvasWidth / 2 - 400 + apronWidth - 20) * scaleX, runwayY + runwayHeight * scaleY - 20 * scaleY, 20 * scaleX, 20 * scaleY);

            // ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãƒ“ãƒ«
            ctx.fillStyle = terminalColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100 + apronWidth / 2 - terminalWidth / 2) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY - terminalHeight * scaleY), terminalWidth * scaleX, terminalHeight * scaleY);

            // ç®¡åˆ¶å¡”
            ctx.fillStyle = controlTowerColor;
            ctx.fillRect(controlTowerX - (controlTowerWidth / 2) * scaleX, controlTowerY, controlTowerWidth * scaleX, controlTowerHeight * scaleY);
            ctx.fillStyle = '#ADD8E6'; // çª“
            ctx.fillRect(controlTowerX - (controlTowerWidth / 2) * scaleX, controlTowerY - 15 * scaleY, controlTowerWidth * scaleX, 15 * scaleY);
        }

        /**
         * é£›è¡Œæ©Ÿã‚’æç”»ã™ã‚‹é–¢æ•°
         * ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦æç”»
         */
        function drawPlane(x, y, width, height, color = '#A52A2A') {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;
            
            const scaledX = x * scaleX;
            const scaledY = y * scaleY;
            const scaledWidth = width * scaleX;
            const scaledHeight = height * scaleY;

            ctx.fillStyle = color;
            ctx.fillRect(scaledX - scaledWidth / 2, scaledY - scaledHeight / 2, scaledWidth, scaledHeight);
            ctx.fillRect(scaledX - scaledWidth / 2 - 20 * scaleX, scaledY - scaledHeight / 2 + 10 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect(scaledX + scaledWidth / 2, scaledY - scaledHeight / 2 + 10 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect(scaledX - 5 * scaleX, scaledY + scaledHeight / 2, 10 * scaleX, 15 * scaleY);
            ctx.fillStyle = '#333';
            ctx.fillRect(scaledX - 10 * scaleX, scaledY - scaledHeight / 2 - 5 * scaleY, 20 * scaleX, 10 * scaleY);
        }

        /**
         * é›²ã‚’æç”»ã™ã‚‹é–¢æ•°
         * ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦æç”»
         */
        function drawCloud(x, y, size) {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x * scaleX, y * scaleY, size * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x + size * 0.6) * scaleX, (y - size * 0.3) * scaleY, size * 0.8 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x - size * 0.7) * scaleX, (y - size * 0.2) * scaleY, size * 0.9 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x + size * 0.3) * scaleX, (y + size * 0.4) * scaleY, size * 0.7 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
         */
        function updateGame() {
            // ãƒ«ãƒ¼ãƒ«èª¬æ˜ãƒ•ã‚§ãƒ¼ã‚º
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            if (!gameActive) {
                // å„ãƒ•ã‚§ãƒ¼ã‚ºã®é–‹å§‹å¾…æ©Ÿ
                switch(currentPhase) {
                    case GAME_PHASE.TAKEOFF_CLEARANCE:
                        if (showTakeOffClearance && !takeOffClearanceSpoken) {
                            speakMessage("Cleared for take off.");
                            takeOffClearanceSpoken = true;
                        }
                        if (Date.now() - takeOffClearanceStartTime > takeOffClearanceDuration) {
                            showTakeOffClearance = false;
                            gameActive = true; // ã‚²ãƒ¼ãƒ é–‹å§‹
                            currentPhase = GAME_PHASE.FLIGHT;
                            flightTimeElapsed = 0; // é£›è¡Œæ™‚é–“è¨ˆæ¸¬é–‹å§‹
                            timerDisplay.style.display = 'block';
                            showControls(); // é£›è¡Œä¸­ã¯æ“ä½œãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                        }
                        break;
                    case GAME_PHASE.LANDING_CLEARANCE:
                        if (showLandingClearance && !landingClearanceSpoken) {
                            speakMessage("Cleared to land.");
                            landingClearanceSpoken = true;
                        }
                        if (Date.now() - landingClearanceStartTime > landingClearanceDuration) {
                            showLandingClearance = false;
                            gameActive = true; // ç€é™¸ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹
                            currentPhase = GAME_PHASE.LANDING;
                            landingGuide.style.display = 'block'; // ç€é™¸ã‚¬ã‚¤ãƒ‰è¡¨ç¤º
                            showControls(); // ç€é™¸æ™‚ã¯æ“ä½œãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                        }
                        break;
                }
                return; // ã‚²ãƒ¼ãƒ ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ãªã„é–“ã¯ã€æ›´æ–°å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
            }

            // é£›è¡Œãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
            if (currentPhase === GAME_PHASE.FLIGHT) {
                flightTimeElapsed += 1000 / 60; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç´„1/60ç§’ã¨ã™ã‚‹
                const remainingTime = Math.max(0, (flightDurationRequired - flightTimeElapsed) / 1000);
                timerDisplay.innerText = `é£›è¡Œæ™‚é–“: ${Math.floor(flightTimeElapsed / 1000)}ç§’ / ${flightDurationRequired / 1000}ç§’`;

                if (flightTimeElapsed >= flightDurationRequired) {
                    // é£›è¡Œæ™‚é–“é”æˆã—ãŸã‚‰ç€é™¸ãƒ•ã‚§ãƒ¼ã‚ºã¸ç§»è¡Œ
                    gameActive = false; // ä¸€æ™‚åœæ­¢
                    showLandingClearance = true;
                    landingClearanceStartTime = Date.now();
                    currentPhase = GAME_PHASE.LANDING_CLEARANCE;
                    timerDisplay.style.display = 'none'; // ã‚¿ã‚¤ãƒãƒ¼éè¡¨ç¤º
                    // ä»–ã®é£›è¡Œæ©Ÿã‚’ã‚¯ãƒªã‚¢
                    otherPlanes.length = 0;
                    otherPlaneSpawnTimer = 0;
                    clouds.length = 0; // é›²ã‚‚ãƒªã‚»ãƒƒãƒˆã—ã¦ç€é™¸ãƒ•ã‚§ãƒ¼ã‚ºã¸å‚™ãˆã‚‹
                    showControls(); // ç€é™¸ãƒ•ã‚§ãƒ¼ã‚ºç§»è¡Œæ™‚ã«æ“ä½œãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                }
            }
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ã®å…¥åŠ›ã‚’çµ±åˆ
            if (keys.ArrowRight || keys.RightButton) {
                planeSpeedX += acceleration;
                if (planeSpeedX > maxGroundSpeed) planeSpeedX = maxGroundSpeed;
            } else if (keys.ArrowLeft || keys.LeftButton) {
                planeSpeedX -= acceleration;
                if (planeSpeedX < -maxGroundSpeed) planeSpeedX = -maxGroundSpeed;
            } else {
                if (!isInAir) { // åœ°ä¸Šã«ã„ã‚‹æ™‚ã®ã¿æ¸›é€Ÿ
                    if (planeSpeedX > 0) {
                        planeSpeedX -= acceleration / 2;
                        if (planeSpeedX < 0) planeSpeedX = 0;
                    } else if (planeSpeedX < 0) {
                        planeSpeedX += acceleration / 2;
                        if (planeSpeedX > 0) planeSpeedX = 0;
                    }
                }
            }

            if (!isInAir) {
                // åœ°ä¸Šã§ã®æ“ä½œ
                planeX += planeSpeedX;

                // é›¢é™¸åˆ¤å®š (FLIGHTãƒ•ã‚§ãƒ¼ã‚ºã®æ™‚ã®ã¿é›¢é™¸å¯èƒ½)
                if ((keys.ArrowUp || keys.UpButton) && planeSpeedX > 3 && currentPhase === GAME_PHASE.FLIGHT) {
                    planeSpeedY = lift;
                    isInAir = true;
                }

                // åœ°é¢ã«æ¥ã—ã¦ã„ã‚‹çŠ¶æ…‹ã«å›ºå®š
                planeY = initialCanvasHeight - 50;
                
                if (planeX < planeWidth / 2) {
                    planeX = planeWidth / 2;
                    planeSpeedX = 0;
                }
                if (planeX > initialCanvasWidth - planeWidth / 2) {
                    planeX = initialCanvasWidth - planeWidth / 2;
                    planeSpeedX = 0;
                }

            } else { // ç©ºä¸­ã§ã®æ“ä½œ
                if (keys.ArrowUp || keys.UpButton) {
                    planeSpeedY = Math.max(-maxAirSpeedY, planeSpeedY + lift);
                }
                if (keys.ArrowDown || keys.DownButton) {
                    planeSpeedY = Math.min(maxAirSpeedY, planeSpeedY + gravity);
                }

                planeSpeedY += gravity;
                planeY += planeSpeedY;
                planeX += planeSpeedX * 0.5; // ç©ºä¸­ã§ã¯æ°´å¹³é€Ÿåº¦ã‚’å°‘ã—ç¶­æŒ

                if (planeY < planeHeight / 2) { // ç”»é¢ä¸Šç«¯ã«ã¶ã¤ã‹ã‚‰ãªã„ã‚ˆã†ã«
                    planeY = planeHeight / 2;
                    planeSpeedY = 0;
                }
                if (planeX < planeWidth / 2) planeX = planeWidth / 2;
                if (planeX > initialCanvasWidth - planeWidth / 2) planeX = initialCanvasWidth - planeWidth / 2;
                
                // ç€é™¸åˆ¤å®š: LANDINGãƒ•ã‚§ãƒ¼ã‚ºä¸­
                const currentScaledTargetLandingAltitude = targetLandingAltitude;
                const currentScaledLandingAltitudeTolerance = landingAltitudeTolerance * (canvas.height / initialCanvasHeight);

                if (currentPhase === GAME_PHASE.LANDING && planeY * (canvas.height / initialCanvasHeight) >= currentScaledTargetLandingAltitude - currentScaledLandingAltitudeTolerance) {
                    let failureReason = [];

                    // é«˜åº¦ãƒã‚§ãƒƒã‚¯
                    if (planeY * (canvas.height / initialCanvasHeight) > currentScaledTargetLandingAltitude + currentScaledLandingAltitudeTolerance || planeY * (canvas.height / initialCanvasHeight) < currentScaledTargetLandingAltitude - currentScaledLandingAltitudeTolerance) {
                         failureReason.push('ç€åœ°ä½ç½®ãŒæ»‘èµ°è·¯ã‹ã‚‰é›¢ã‚Œã™ãã¾ã—ãŸï¼');
                    }

                    // å‚ç›´é€Ÿåº¦ãƒã‚§ãƒƒã‚¯
                    if (Math.abs(planeSpeedY) >= targetVerticalSpeed) {
                        failureReason.push(`æ¥åœ°é€Ÿåº¦(${Math.abs(planeSpeedY).toFixed(1)})ãŒé€Ÿã™ãã¾ã™ï¼ã‚‚ã†å°‘ã—å„ªã—ãç€åœ°ã—ã¦ãã ã•ã„ã€‚`);
                    }

                    if (failureReason.length === 0) {
                        isInAir = false;
                        planeSpeedY = 0;
                        planeY = initialCanvasHeight - 50;
                        gameClear('ç€é™¸æˆåŠŸï¼ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼');
                        return;
                    } else {
                        // å¤±æ•—ã—ãŸå ´åˆã€å…·ä½“çš„ãªç†ç”±ã‚’è¡¨ç¤º
                        gameOver('ç€é™¸å¤±æ•—ï¼' + failureReason.join(' '));
                        return;
                    }
                } else if (planeY * (canvas.height / initialCanvasHeight) > canvas.height + planeHeight * (canvas.height / initialCanvasHeight)) {
                    // ç”»é¢ä¸‹ã¾ã§è½ã¡ãŸã‚‰ç„¡æ¡ä»¶ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆé«˜åº¦ãŒè¶³ã‚Šãšã«å¢œè½ï¼‰
                    gameOver('ç€é™¸ã«å¤±æ•—ã—ã¾ã—ãŸï¼é«˜åº¦ãŒä½ã™ãã¾ã—ãŸã€‚');
                    return;
                }

                // é›²ã®ç”Ÿæˆã¨ç§»å‹•
                if (planeY < airportDisappearAltitude && (currentPhase === GAME_PHASE.FLIGHT || currentPhase === GAME_PHASE.LANDING_CLEARANCE)) {
                    if (clouds.length < maxClouds && Math.random() < 0.01) {
                        clouds.push({
                            x: initialCanvasWidth,
                            y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50, /* é›²ã®Yåº§æ¨™ã‚’èª¿æ•´ */
                            size: Math.random() * 50 + 30
                        });
                    }
                }
                for (let i = clouds.length - 1; i >= 0; i--) {
                    clouds[i].x -= cloudSpeed;
                    if (clouds[i].x < -clouds[i].size) {
                        clouds.splice(i, 1);
                    }
                }

                // ä»–ã®é£›è¡Œæ©Ÿã®ç”Ÿæˆã¨ç§»å‹• (FLIGHTãƒ•ã‚§ãƒ¼ã‚ºä¸­ã®ã¿)
                if (currentPhase === GAME_PHASE.FLIGHT) {
                    otherPlaneSpawnTimer++;
                    if (otherPlanes.length < maxOtherPlanes && otherPlaneSpawnTimer >= otherPlaneSpawnInterval) {
                        if (Math.random() < 0.5) { // å·¦ã‹ã‚‰å‡ºç¾
                            otherPlanes.push({
                                x: -planeWidth,
                                y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50,
                                speed: Math.random() * (otherPlaneSpeedMax - otherPlaneSpeedMin) + otherPlaneSpeedMin,
                                direction: 1
                            });
                        } else { // å³ã‹ã‚‰å‡ºç¾
                            otherPlanes.push({
                                x: initialCanvasWidth + planeWidth,
                                y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50,
                                speed: Math.random() * (otherPlaneSpeedMax - otherPlaneSpeedMin) + otherPlaneSpeedMin,
                                direction: -1
                            });
                        }
                        otherPlaneSpawnTimer = 0;
                    }

                    for (let i = 0; i < otherPlanes.length; i++) {
                        const op = otherPlanes[i];
                        op.x += op.speed * op.direction;
                        if (op.direction === 1 && op.x > initialCanvasWidth + planeWidth * 2 ||
                            op.direction === -1 && op.x < -planeWidth * 2) {
                            otherPlanes.splice(i, 1);
                            i--;
                        }
                    }

                    // è¡çªåˆ¤å®š
                    for (let i = 0; i < otherPlanes.length; i++) {
                        const op = otherPlanes[i];
                        if (
                            planeX - planeWidth / 2 < op.x + planeWidth / 2 &&
                            planeX + planeWidth / 2 > op.x - planeWidth / 2 &&
                            planeY - planeHeight / 2 < op.y + planeHeight / 2 &&
                            planeY + planeHeight / 2 > op.y - planeHeight / 2
                        ) {
                            gameOver('ä»–ã®é£›è¡Œæ©Ÿã¨è¡çªï¼å¢œè½ã—ã¾ã—ãŸï¼');
                            return;
                        }
                    }
                }
            }
        }

        /**
         * ã‚²ãƒ¼ãƒ è¦ç´ ã‚’æç”»ã™ã‚‹é–¢æ•°
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // ç”»é¢ã‚’ã‚¯ãƒªã‚¢

            // ãƒ«ãƒ¼ãƒ«èª¬æ˜ä¸­ã¯ã‚²ãƒ¼ãƒ è¦ç´ ã‚’æç”»ã—ãªã„
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // é›²ã‚’æç”» (é£›è¡Œæ©Ÿã®é«˜åº¦ã«ã‚ˆã£ã¦è¡¨ç¤º)
            if (planeY < airportDisappearAltitude && (currentPhase === GAME_PHASE.FLIGHT || currentPhase === GAME_PHASE.LANDING_CLEARANCE)) {
                for (const cloud of clouds) {
                    drawCloud(cloud.x, cloud.y, cloud.size);
                }
            }

            // ç©ºæ¸¯ã®æç”» (ç‰¹å®šã®ãƒ•ã‚§ãƒ¼ã‚ºã¨é«˜åº¦ã§ã®ã¿è¡¨ç¤º)
            const isAirportVisible = (currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || 
                                      currentPhase === GAME_PHASE.LANDING_CLEARANCE || 
                                      (currentPhase === GAME_PHASE.FLIGHT && planeY > airportDisappearAltitude) ||
                                      (currentPhase === GAME_PHASE.LANDING && planeY > airportReappearAltitude));

            if (isAirportVisible) {
                drawRunway();
                drawAirport();
            }
            
            drawPlane(planeX, planeY, planeWidth, planeHeight); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é£›è¡Œæ©Ÿ

            // ä»–ã®é£›è¡Œæ©Ÿã‚’æç”»
            for (const op of otherPlanes) {
                drawPlane(op.x, op.y, planeWidth * 0.8, planeHeight * 0.8, '#008000'); // ä»–ã®é£›è¡Œæ©Ÿã¯å°‘ã—å°ã•ãç·‘è‰²
            }

            // é›¢é™¸è¨±å¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (showTakeOffClearance && currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE) {
                ctx.font = `${30 * scaleY}px Arial Black`;
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText("Cleared for take off", controlTowerX, controlTowerY - 30 * scaleY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * Math.min(scaleX, scaleY);
                ctx.strokeText("Cleared for take off", controlTowerX, controlTowerY - 30 * scaleY);
            }

            // ç€é™¸è¨±å¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (showLandingClearance && currentPhase === GAME_PHASE.LANDING_CLEARANCE) {
                ctx.font = `${30 * scaleY}px Arial Black`;
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText("Cleared to land", controlTowerX, controlTowerY - 30 * scaleY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * Math.min(scaleX, scaleY);
                ctx.strokeText("Cleared to land", controlTowerX, controlTowerY - 30 * scaleY);
            }

            // ç€é™¸ã‚¬ã‚¤ãƒ‰ã®è¡¨ç¤º
            if (currentPhase === GAME_PHASE.LANDING && gameActive) {
                landingGuide.style.display = 'block';

                const currentAltitude = Math.floor(initialCanvasHeight - planeY);
                const goalAltitude = Math.floor(initialCanvasHeight - (initialCanvasHeight - runwayHeight) + planeHeight / 2);

                const currentVspeed = (planeSpeedY * 10).toFixed(1);
                const currentHspeed = (planeSpeedX * 10).toFixed(1);

                let guideText = '--- ç€é™¸ã‚¬ã‚¤ãƒ‰ ---\n';
                
                guideText += `é«˜åº¦: ${currentAltitude}m (ç›®æ¨™: ${goalAltitude}m Â±${landingAltitudeTolerance}m)\n`;
                if (currentAltitude > goalAltitude + landingAltitudeTolerance) {
                    guideText += '  â†‘ é«˜ã™ãã¾ã™ï¼ã‚‚ã£ã¨ä¸‹é™ã‚’ã€‚\n';
                } else if (currentAltitude < goalAltitude - landingAltitudeTolerance) {
                    guideText += '  â†“ ä½ã™ãã¾ã™ï¼å°‘ã—ä¸Šæ˜‡ã‚’ã€‚\n';
                } else {
                    guideText += '  â— é«˜åº¦è‰¯å¥½\n';
                }

                guideText += `å‚ç›´é€Ÿåº¦: ${currentVspeed}km/h (ç›®æ¨™: <${(targetVerticalSpeed * 10).toFixed(1)}km/h)\n`;
                if (Math.abs(planeSpeedY) >= targetVerticalSpeed) {
                    guideText += '  â†“ å‚ç›´é€Ÿåº¦ãŒé€Ÿã™ãã¾ã™ï¼å„ªã—ãã€‚\n';
                } else {
                    guideText += '  â— å‚ç›´é€Ÿåº¦è‰¯å¥½\n';
                }

                guideText += `æ°´å¹³é€Ÿåº¦: ${currentHspeed}km/h\n`; 

                landingGuide.innerText = guideText;
            } else {
                landingGuide.style.display = 'none';
            }
        }

        /**
         * ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†
         */
        function gameOver(message) {
            gameActive = false;
            currentPhase = GAME_PHASE.GAME_OVER;
            gameStatusMessage.innerText = message;
            messageOverlay.style.display = 'flex';
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';
            showRulesButton.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯ãƒ«ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            if (synth.speaking) {
                synth.cancel();
            }
            hideControls(); // æ“ä½œãƒœã‚¿ãƒ³ã‚’éš ã™
            canvas.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã‚‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’éè¡¨ç¤º
        }

        /**
         * ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å‡¦ç†
         */
        function gameClear(message) {
            gameActive = false;
            currentPhase = GAME_PHASE.GAME_CLEAR;
            gameStatusMessage.innerText = message;
            messageOverlay.style.display = 'flex';
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';
            showRulesButton.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã¯ãƒ«ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            if (synth.speaking) {
                synth.cancel();
            }
            hideControls(); // æ“ä½œãƒœã‚¿ãƒ³ã‚’éš ã™
            canvas.style.display = 'none'; // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢æ™‚ã‚‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’éè¡¨ç¤º
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
         */
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.addEventListener('keydown', (e) => {
            // ãƒ«ãƒ¼ãƒ«èª¬æ˜ä¸­ã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œã‚’ç„¡åŠ¹åŒ–
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            if (!gameActive && e.key !== 'Space' && currentPhase !== GAME_PHASE.TAKEOFF_CLEARANCE && currentPhase !== GAME_PHASE.LANDING_CLEARANCE) return;

            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        // ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        function setupTouchButton(buttonElement, keyName) {
            buttonElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // ãƒ«ãƒ¼ãƒ«èª¬æ˜ä¸­ã¯ã‚¿ãƒƒãƒãƒœã‚¿ãƒ³æ“ä½œã‚’ç„¡åŠ¹åŒ–
                if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
                if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys[keyName] = true;
            });
            buttonElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[keyName] = false;
            });
            buttonElement.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys[keyName] = false;
            });
        }

        setupTouchButton(upButton, 'UpButton');
        setupTouchButton(downButton, 'DownButton');
        setupTouchButton(leftButton, 'LeftButton');
        setupTouchButton(rightButton, 'RightButton');

        // ä»®æƒ³ã‚¿ãƒƒãƒã‚¨ãƒªã‚¢ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        leftTouchArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // ãƒ«ãƒ¼ãƒ«èª¬æ˜ä¸­ã¯ã‚¿ãƒƒãƒã‚¨ãƒªã‚¢æ“ä½œã‚’ç„¡åŠ¹åŒ–
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
            if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys.LeftButton = true;
        });
        leftTouchArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.LeftButton = false;
        });
        leftTouchArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys.LeftButton = false;
        });

        rightTouchArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // ãƒ«ãƒ¼ãƒ«èª¬æ˜ä¸­ã¯ã‚¿ãƒƒãƒã‚¨ãƒªã‚¢æ“ä½œã‚’ç„¡åŠ¹åŒ–
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
            if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys.RightButton = true;
        });
        rightTouchArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.RightButton = false;
        });
        rightTouchArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys.RightButton = false;
        });


        // ãƒªãƒˆãƒ©ã‚¤ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        restartButton.addEventListener('click', resetGame);

        // ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        startGameButton.addEventListener('click', () => {
            hideRulesExplanation(); // ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚’éš ã™
            // æœ€åˆã®ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆé›¢é™¸è¨±å¯ï¼‰ã‚’é–‹å§‹
            currentPhase = GAME_PHASE.TAKEOFF_CLEARANCE;
            takeOffClearanceStartTime = Date.now();
            // æ“ä½œãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºï¼ˆé›¢é™¸å‰ã‹ã‚‰è¡¨ç¤ºï¼‰
            showControls();
            showRulesButton.style.display = 'block'; // ã‚²ãƒ¼ãƒ é–‹å§‹å¾Œã«ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
        });

        // ãƒ«ãƒ¼ãƒ«è¡¨ç¤ºãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        showRulesButton.addEventListener('click', showRulesExplanation);


        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
        window.addEventListener('resize', resizeCanvas);

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        resizeCanvas(); // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’èª¿æ•´
        resetGame(); // åˆæœŸåŒ–æ™‚ã«ãƒ«ãƒ¼ãƒ«èª¬æ˜ã‚’è¡¨ç¤º
        gameLoop();
    </script>
</body>
</html>