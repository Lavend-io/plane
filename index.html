<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>飛び立て！未来の空へ！</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #ADD8E6; /* 薄い水色 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            position: relative;
            /* 飛行機のシルエットを背景に繰り返し表示 */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAhUlEQVQ4T2NkYGBg+M+ACUc+IwgcwAhFAzEwMDg0MDAwNgZGBgYGYwMDEwMYAImAgYQoQFIUgCjhCAQowGQoQAYkUAUkwFQQgJhUgEwpgMQpQCI0oAEQpAERZgAQAo4m40xhlSUAAAAASUVORK5CYII=');
            background-repeat: repeat;
        }
        canvas {
            border: 2px solid #333;
            background-color: #87CEEB; /* 空のイメージ */
            display: block;
            max-width: 100%;
            height: auto;
        }
        #message-overlay, #rules-overlay {
            position: fixed; /* absolute から fixed に変更して、常にビューポート全体を覆うように */
            top: 0;
            left: 0;
            width: 100vw; /* 常にビューポートの幅 */
            height: 100vh; /* 常にビューポートの高さ */
            background-color: rgba(0, 0, 0, 0.9); /* さらに不透明度を上げて、下の要素を隠す */
            color: white;
            display: flex;
            justify-content: center; /* 中央揃え */
            align-items: center;     /* 中央揃え */
            flex-direction: column;
            text-align: center;
            display: none;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }
        #rules-overlay > div { /* ルールコンテンツを囲む新しいdivを追加（中央寄せ用） */
            max-width: 700px;
            width: 90%; /* 画面幅の90%を最大に */
            background-color: rgba(0, 0, 0, 0.8); /* コンテンツの背景色を少し明るく */
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            text-align: left; /* テキストを左寄せに */
            overflow-y: auto; /* コンテンツがはみ出したらスクロール可能に */
            max-height: 90vh; /* 画面高の90%を最大に */
        }
        #rules-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            color: #FFD700;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        #rules-overlay h3 {
            font-size: 1.8em;
            margin-top: 25px;
            margin-bottom: 15px;
            color: #ADD8E6;
            text-align: center;
        }
        #rules-overlay p, #rules-overlay ul, #rules-overlay ol {
            margin-bottom: 15px;
            padding: 0 20px;
            text-align: left;
        }
        #rules-overlay li {
            margin-bottom: 8px;
        }
        #rules-overlay strong {
            color: #FFECB3;
        }
        #message-overlay button, #rules-overlay button {
            font-size: 1.6em;
            padding: 12px 25px;
            margin-top: 30px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        #message-overlay button:hover, #rules-overlay button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        #message-overlay button:active, #rules-overlay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #timer-display, #landing-guide {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #333;
            font-size: 1.5em;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            display: none;
            line-height: 1.4;
            z-index: 20;
        }
        #landing-guide {
            top: 10px;
            right: 10px;
            left: auto;
            text-align: left;
        }
        #game-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: pink;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 50;
            pointer-events: none;
            white-space: nowrap;
        }

        /* ゲーム中ルール確認ボタンのスタイル */
        #show-rules-button {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 1.2em;
            padding: 8px 15px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #6495ED;
            color: white;
            z-index: 110;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, transform 0.1s;
        }
        #show-rules-button:hover {
            background-color: #558BEF;
            transform: translateY(-1px);
        }
        #show-rules-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }


        /* スマートフォン用操作ボタンのスタイル */
        .controls-container {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 60;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .control-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1.8em;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            opacity: 0.8;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .control-button:active {
            opacity: 1;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .horizontal-controls {
            display: flex;
            gap: 10px;
        }

        .vertical-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* 画面左右の仮想ボタン領域 */
        .touch-area {
            position: absolute;
            top: 0;
            height: 100%;
            width: 25%;
            z-index: 10;
        }

        #left-touch-area {
            left: 0;
        }

        #right-touch-area {
            right: 0;
        }

        /* スマホでの表示を調整 */
        @media (max-width: 768px) {
            #game-title {
                font-size: 1.8em;
            }
            #message-overlay {
                font-size: 2.5em;
            }
            #message-overlay button {
                font-size: 1.2em;
                padding: 8px 15px;
            }
            #rules-overlay > div { /* スマホ向け調整 */
                font-size: 0.9em;
                padding: 15px;
                width: 95%; /* より画面いっぱいに */
                max-height: 95vh;
            }
            #rules-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            #rules-overlay h3 {
                font-size: 1.3em;
                margin-top: 15px;
                margin-bottom: 10px;
            }
            #rules-overlay p, #rules-overlay ul, #rules-overlay ol {
                padding: 0 10px;
            }
            #rules-overlay button {
                font-size: 1.2em;
                padding: 10px 20px;
                margin-top: 20px;
            }
            #timer-display, #landing-guide {
                font-size: 1em;
                padding: 3px 6px;
            }
            #show-rules-button {
                font-size: 1em;
                padding: 6px 12px;
                top: 40px;
            }
            .control-button {
                padding: 10px 15px;
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="game-title">飛び立て！未来の空へ！</div>
    <div id="timer-display"></div>
    <button id="show-rules-button">ルール</button>
    <div id="landing-guide"></div>

    <div class="controls-container">
        <div class="horizontal-controls">
            <button id="left-button" class="control-button">←</button>
            <button id="right-button" class="control-button">→</button>
        </div>
        <div class="vertical-controls">
            <button id="up-button" class="control-button">↑</button>
            <button id="down-button" class="control-button">↓</button>
        </div>
    </div>

    <div id="left-touch-area" class="touch-area"></div>
    <div id="right-touch-area" class="touch-area"></div>

    <div id="message-overlay">
        <span id="game-status-message"></span>
        <button id="restart-button">リトライ</button>
    </div>

    <div id="rules-overlay">
        <div> <h2>✈️ 未来のパイロットよ、準備はいいか？ ✈️</h2>
            <p>
                このゲームは、君の操縦スキルが試される、スリリングなフライトシミュレーターだ！<br>
                大空を駆け巡り、無事に着陸できるか挑戦しよう！
            </p>
            <h3>🚀 操作方法</h3>
            <ul>
                <li><strong>キーボード:</strong> 矢印キー (↑ 上昇, ↓ 下降, ← 左移動, → 右移動)</li>
                <li><strong>スマートフォン:</strong> 画面下の操作ボタン、または画面左右の仮想タッチエリアをタップ！</li>
            </ul>
            <h3>🎮 ゲームの流れ</h3>
            <ol>
                <li><strong>離陸準備 & 許可:</strong> 管制塔からの指示を待とう！</li>
                <li><strong>大空へテイクオフ！:</strong> 地上で十分に加速したら、機首を上げて離陸だ！</li>
                <li><strong>フライトタイム (20秒):</strong> 雲の上を自由に飛行！ただし、他の飛行機との衝突には要注意！</li>
                <li><strong>着陸許可 & アプローチ:</strong> 飛行時間が終わると、着陸の指示が来るぞ。</li>
                <li><strong>安全に着陸！:</strong> 滑走路を目指して、慎重に高度と速度を調整だ！特に、接地時の「垂直速度」をゆっくりに、そして「滑走路の真ん中」に着地できれば大成功！</li>
            </ol>
            <p>さあ、君のフライトが始まる！安全な着陸を目指して、最高のパイロットになろう！</p>
            <button id="start-game-button">ゲームスタート！</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageOverlay = document.getElementById('message-overlay');
        const gameStatusMessage = document.getElementById('game-status-message');
        const restartButton = document.getElementById('restart-button');
        const timerDisplay = document.getElementById('timer-display');
        const landingGuide = document.getElementById('landing-guide');
        const gameTitleDisplay = document.getElementById('game-title');

        // ルール説明関連要素
        const rulesOverlay = document.getElementById('rules-overlay');
        const startGameButton = document.getElementById('start-game-button');

        // ゲーム中ルール確認ボタン
        const showRulesButton = document.getElementById('show-rules-button');

        // スマホ操作ボタン要素
        const upButton = document.getElementById('up-button');
        const downButton = document.getElementById('down-button');
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const controlsContainer = document.querySelector('.controls-container');

        // 仮想タッチエリア要素
        const leftTouchArea = document.getElementById('left-touch-area');
        const rightTouchArea = document.getElementById('right-touch-area');

        // 音声読み上げオブジェクトの準備
        const synth = window.speechSynthesis;
        const utterance = new SpeechSynthesisUtterance();
        utterance.lang = 'en-US'; // 英語で読み上げ（管制塔の雰囲気）
        utterance.volume = 1;     // 音量
        utterance.rate = 1.0;     // 速度
        utterance.pitch = 1.0;    // ピッチ

        // ゲームの状態
        let gameActive = false; // 初期状態では操作不可

        // ゲームフェーズ管理
        const GAME_PHASE = {
            RULES_EXPLANATION: 0, // 新しいフェーズ
            TAKEOFF_CLEARANCE: 1,
            FLIGHT: 2,
            LANDING_CLEARANCE: 3,
            LANDING: 4,
            GAME_OVER: 5,
            GAME_CLEAR: 6
        };
        let currentPhase = GAME_PHASE.RULES_EXPLANATION; // 初期フェーズをルール説明に設定

        // 離陸許可メッセージ関連
        let showTakeOffClearance = true;
        const takeOffClearanceDuration = 3000; // 3秒間表示
        let takeOffClearanceStartTime;
        let takeOffClearanceSpoken = false; // 読み上げ済みかどうかのフラグ

        // 飛行フェーズのタイマー
        let flightTimeElapsed = 0;
        const flightDurationRequired = 20 * 1000; // 飛行時間目標を20秒に延長

        // 着陸許可メッセージ関連
        let showLandingClearance = false;
        const landingClearanceDuration = 5000; // 5秒間表示
        let landingClearanceStartTime;
        let landingClearanceSpoken = false; // 読み上げ済みかどうかのフラグ

        // 飛行機の初期設定 (原寸大の比率で初期化)
        const initialCanvasWidth = 800;
        const initialCanvasHeight = 600;
        let planeX = initialCanvasWidth / 2;
        let planeY = initialCanvasHeight - 50;
        const planeWidth = 60;
        const planeHeight = 40;
        let planeSpeedX = 0;
        let planeSpeedY = 0;
        const acceleration = 0.2;
        const gravity = 0.1;
        const lift = -0.5;
        const maxGroundSpeed = 5;
        const maxAirSpeedY = 8; // 最大上昇・下降速度
        let isInAir = false;
        const airportDisappearAltitude = initialCanvasHeight - 200; // この高度を超えると空港が消える
        const airportReappearAltitude = initialCanvasHeight - 100; // この高度を下回ると空港が出現

        // 滑走路の設定 (原寸大の比率で初期化)
        const runwayHeight = 80;
        let runwayY = initialCanvasHeight - runwayHeight;
        const runwayColor = '#808080';
        const runwayLineColor = '#FFF';
        const runwayLineWidth = 5;

        // 空港施設の設定 (原寸大の比率で初期化)
        const terminalWidth = 150;
        const terminalHeight = 80;
        const terminalColor = '#A9A9A9';

        const controlTowerWidth = 20;
        const controlTowerHeight = 100;
        const controlTowerColor = '#696969';
        let controlTowerX = initialCanvasWidth / 2 + 100 + 150 / 2 + 20 + controlTowerWidth / 2;
        let controlTowerY = runwayY + runwayHeight - terminalHeight - controlTowerHeight - 20;

        const apronColor = '#606060';
        const apronWidth = 300;
        const apronHeight = 100;

        // 雲の設定
        const clouds = [];
        const maxClouds = 10;
        const cloudSpeed = 1;

        // 他の飛行機の設定
        const otherPlanes = [];
        const maxOtherPlanes = 3;
        const otherPlaneSpeedMin = 2;
        const otherPlaneSpeedMax = 4;
        const otherPlaneSpawnInterval = 300;
        let otherPlaneSpawnTimer = 0;

        // キーボードとタッチの状態を統合管理
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            // タッチボタンの状態
            UpButton: false,
            DownButton: false,
            LeftButton: false,
            RightButton: false
        };

        // 着陸成功条件の閾値（大幅に緩和）
        const targetVerticalSpeed = 5; // 絶対値5未満に緩和
        const landingAltitudeTolerance = 20; // 滑走路の高さから上下20px以内であればOK
        let targetLandingAltitude = runwayY - planeHeight / 2; // 地面に接するY座標

        // キャンバスのリサイズ処理
        function resizeCanvas() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            // アスペクト比を維持して内部解像度を設定
            let aspectRatio = initialCanvasWidth / initialCanvasHeight;
            let newWidth, newHeight;

            if (displayWidth / displayHeight > aspectRatio) {
                newHeight = displayHeight;
                newWidth = displayHeight * aspectRatio;
            } else {
                newWidth = displayWidth;
                newHeight = displayWidth / aspectRatio;
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // ゲーム要素の座標を新しいキャンバスサイズに合わせてスケール
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // 固定要素のY座標を再計算
            runwayY = canvas.height - runwayHeight * scaleY;
            targetLandingAltitude = runwayY - planeHeight * scaleY / 2; // 着陸目標高度もスケール
            controlTowerX = (initialCanvasWidth / 2 + 100 + 150 / 2 + 20 + controlTowerWidth / 2) * scaleX;
            controlTowerY = runwayY + runwayHeight * scaleY - terminalHeight * scaleY - controlTowerHeight * scaleY - 20 * scaleY;
        }

        // 音声読み上げ関数
        function speakMessage(message) {
            if (synth.speaking) {
                synth.cancel(); // 既に読み上げ中の場合はキャンセル
            }
            utterance.text = message;
            synth.speak(utterance);
        }

        // ゲームのリセット関数
        function resetGame() {
            // 初期設定値に基づいてリセット
            planeX = initialCanvasWidth / 2;
            planeY = initialCanvasHeight - 50;
            planeSpeedX = 0;
            planeSpeedY = 0;
            isInAir = false;
            gameActive = false;
            clouds.length = 0;
            otherPlanes.length = 0;
            otherPlaneSpawnTimer = 0;
            flightTimeElapsed = 0;
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';

            messageOverlay.style.display = 'none';

            showTakeOffClearance = true;
            takeOffClearanceSpoken = false;
            showLandingClearance = false;
            landingClearanceSpoken = false;

            currentPhase = GAME_PHASE.RULES_EXPLANATION; // リセット時もルール説明から開始
            showRulesExplanation(); // ルール説明を表示
            hideControls(); // 操作ボタンを隠す
            showRulesButton.style.display = 'none'; // リセット時はルール表示ボタンを非表示
        }

        // 操作ボタンの表示/非表示を切り替える関数
        function showControls() {
            controlsContainer.style.display = 'flex';
            leftTouchArea.style.display = 'block';
            rightTouchArea.style.display = 'block';
        }

        function hideControls() {
            controlsContainer.style.display = 'none';
            leftTouchArea.style.display = 'none';
            rightTouchArea.style.display = 'none';
        }

        // ルール説明の表示/非表示
        function showRulesExplanation() {
            rulesOverlay.style.display = 'flex';
            gameTitleDisplay.style.display = 'block'; // タイトルを表示
            canvas.style.display = 'none'; // ゲームキャンバスを非表示にする
            showRulesButton.style.display = 'none'; // ルール表示中はボタンを非表示
            timerDisplay.style.display = 'none'; // タイマーを非表示
            landingGuide.style.display = 'none'; // 着陸ガイドを非表示
            hideControls(); // 操作ボタンを非表示
            gameActive = false; // ルール表示中はゲームを一時停止
        }

        function hideRulesExplanation() {
            rulesOverlay.style.display = 'none';
            gameTitleDisplay.style.display = 'none'; // タイトルを隠す
            canvas.style.display = 'block'; // ゲームキャンバスを表示する
            // ゲームがアクティブまたは特定のフェーズの場合はルール表示ボタンを表示
            if (currentPhase !== GAME_PHASE.RULES_EXPLANATION &&
                currentPhase !== GAME_PHASE.GAME_OVER &&
                currentPhase !== GAME_PHASE.GAME_CLEAR) {
                showRulesButton.style.display = 'block';
            }
            // 各フェーズに応じてUI要素を再表示
            if (currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE) {
                // TAKEOFF_CLEARANCEはゲームActiveではないが、操作ボタンを表示したい
                showControls();
            } else if (currentPhase === GAME_PHASE.FLIGHT) {
                showControls();
                timerDisplay.style.display = 'block';
                gameActive = true; // ゲームを再開
            } else if (currentPhase === GAME_PHASE.LANDING_CLEARANCE) {
                showControls();
            } else if (currentPhase === GAME_PHASE.LANDING) {
                showControls();
                landingGuide.style.display = 'block';
                gameActive = true; // ゲームを再開
            }
        }

        /**
         * 滑走路を描画する関数
         * スケールを考慮して描画
         */
        function drawRunway() {
            const scaleY = canvas.height / initialCanvasHeight;
            const scaledRunwayY = canvas.height - runwayHeight * scaleY;
            const scaledRunwayHeight = runwayHeight * scaleY;
            
            ctx.fillStyle = runwayColor;
            ctx.fillRect(0, scaledRunwayY, canvas.width, scaledRunwayHeight);
            
            // 滑走路の中心線 (白い点線)
            ctx.strokeStyle = runwayLineColor;
            ctx.lineWidth = 4 * scaleY; // 線幅を少し太くする
            ctx.setLineDash([2 * (canvas.width / initialCanvasWidth), 20 * (canvas.width / initialCanvasWidth)]); // 短い線と長めの間隔で点線風
            ctx.beginPath();
            ctx.moveTo(0, scaledRunwayY + scaledRunwayHeight / 2);
            ctx.lineTo(canvas.width, scaledRunwayY + scaledRunwayHeight / 2);
            ctx.stroke();
            ctx.setLineDash([]); // 線ダッシュをリセット (他の描画に影響を与えないように)

            // 滑走路の境界線 (白い実線)
            ctx.strokeStyle = runwayLineColor;
            ctx.lineWidth = 5 * scaleY; // 線幅を調整
            ctx.beginPath();
            ctx.moveTo(0, scaledRunwayY);
            ctx.lineTo(canvas.width, scaledRunwayY);
            ctx.moveTo(0, scaledRunwayY + scaledRunwayHeight);
            ctx.lineTo(canvas.width, scaledRunwayY + scaledRunwayHeight);
            ctx.stroke();
        }
         function drawRunway() {
             ctx.fillStyle = runwayColor;
             ctx.fillRect(0, runwayY, canvas.width, runwayHeight);
 
             // 滑走路のラインを描画
             ctx.strokeStyle = runwayLineColor;
             ctx.lineWidth = runwayLineWidth;
             const lineDashLength = 20;
             const lineGapLength = 30;
             const numDashes = canvas.width / (lineDashLength + lineGapLength);
             ctx.beginPath();
             for (let i = 0; i < numDashes; i++) {
                 const startX = i * (lineDashLength + lineGapLength);
                 ctx.moveTo(startX, runwayY + runwayHeight / 2);
                 ctx.lineTo(startX + lineDashLength, runwayY + runwayHeight / 2);
             }
             ctx.stroke();
         }
        /**
         * 空港施設を描画する関数
         * スケールを考慮して描画
         */
        function drawAirport() {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // 地面
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(0, runwayY, canvas.width, canvas.height - runwayY);

            // 駐機場 (エプロン)
            ctx.fillStyle = apronColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY), apronWidth * scaleX, apronHeight * scaleY);
            ctx.fillRect((initialCanvasWidth / 2 - 400) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY), apronWidth * scaleX, apronHeight * scaleY);

            // 誘導路 (滑走路と駐機場をつなぐ)
            ctx.fillStyle = apronColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100) * scaleX, runwayY + runwayHeight * scaleY - 20 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect((initialCanvasWidth / 2 - 400 + apronWidth - 20) * scaleX, runwayY + runwayHeight * scaleY - 20 * scaleY, 20 * scaleX, 20 * scaleY);

            // ターミナルビル
            ctx.fillStyle = terminalColor;
            ctx.fillRect((initialCanvasWidth / 2 + 100 + apronWidth / 2 - terminalWidth / 2) * scaleX, (runwayY + runwayHeight * scaleY - apronHeight * scaleY - terminalHeight * scaleY), terminalWidth * scaleX, terminalHeight * scaleY);

            // 管制塔
            ctx.fillStyle = controlTowerColor;
            ctx.fillRect(controlTowerX - (controlTowerWidth / 2) * scaleX, controlTowerY, controlTowerWidth * scaleX, controlTowerHeight * scaleY);
            ctx.fillStyle = '#ADD8E6'; // 窓
            ctx.fillRect(controlTowerX - (controlTowerWidth / 2) * scaleX, controlTowerY - 15 * scaleY, controlTowerWidth * scaleX, 15 * scaleY);
        }

        /**
         * 飛行機を描画する関数
         * スケールを考慮して描画
         */
        function drawPlane(x, y, width, height, color = '#A52A2A') {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;
            
            const scaledX = x * scaleX;
            const scaledY = y * scaleY;
            const scaledWidth = width * scaleX;
            const scaledHeight = height * scaleY;

            ctx.fillStyle = color;
            ctx.fillRect(scaledX - scaledWidth / 2, scaledY - scaledHeight / 2, scaledWidth, scaledHeight);
            ctx.fillRect(scaledX - scaledWidth / 2 - 20 * scaleX, scaledY - scaledHeight / 2 + 10 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect(scaledX + scaledWidth / 2, scaledY - scaledHeight / 2 + 10 * scaleY, 20 * scaleX, 20 * scaleY);
            ctx.fillRect(scaledX - 5 * scaleX, scaledY + scaledHeight / 2, 10 * scaleX, 15 * scaleY);
            ctx.fillStyle = '#333';
            ctx.fillRect(scaledX - 10 * scaleX, scaledY - scaledHeight / 2 - 5 * scaleY, 20 * scaleX, 10 * scaleY);
        }

        /**
         * 雲を描画する関数
         * スケールを考慮して描画
         */
        function drawCloud(x, y, size) {
            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x * scaleX, y * scaleY, size * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x + size * 0.6) * scaleX, (y - size * 0.3) * scaleY, size * 0.8 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x - size * 0.7) * scaleX, (y - size * 0.2) * scaleY, size * 0.9 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.arc((x + size * 0.3) * scaleX, (y + size * 0.4) * scaleY, size * 0.7 * Math.min(scaleX, scaleY), 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * ゲームの状態を更新する関数
         */
        function updateGame() {
            // ルール説明フェーズ
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            if (!gameActive) {
                // 各フェーズの開始待機
                switch(currentPhase) {
                    case GAME_PHASE.TAKEOFF_CLEARANCE:
                        if (showTakeOffClearance && !takeOffClearanceSpoken) {
                            speakMessage("Cleared for take off.");
                            takeOffClearanceSpoken = true;
                        }
                        if (Date.now() - takeOffClearanceStartTime > takeOffClearanceDuration) {
                            showTakeOffClearance = false;
                            gameActive = true; // ゲーム開始
                            currentPhase = GAME_PHASE.FLIGHT;
                            flightTimeElapsed = 0; // 飛行時間計測開始
                            timerDisplay.style.display = 'block';
                            showControls(); // 飛行中は操作ボタンを表示
                        }
                        break;
                    case GAME_PHASE.LANDING_CLEARANCE:
                        if (showLandingClearance && !landingClearanceSpoken) {
                            speakMessage("Cleared to land.");
                            landingClearanceSpoken = true;
                        }
                        if (Date.now() - landingClearanceStartTime > landingClearanceDuration) {
                            showLandingClearance = false;
                            gameActive = true; // 着陸フェーズ開始
                            currentPhase = GAME_PHASE.LANDING;
                            landingGuide.style.display = 'block'; // 着陸ガイド表示
                            showControls(); // 着陸時は操作ボタンを表示
                        }
                        break;
                }
                return; // ゲームがアクティブでない間は、更新処理をスキップ
            }

            // 飛行フェーズ中のタイマー更新
            if (currentPhase === GAME_PHASE.FLIGHT) {
                flightTimeElapsed += 1000 / 60; // 1フレームを約1/60秒とする
                const remainingTime = Math.max(0, (flightDurationRequired - flightTimeElapsed) / 1000);
                timerDisplay.innerText = `飛行時間: ${Math.floor(flightTimeElapsed / 1000)}秒 / ${flightDurationRequired / 1000}秒`;

                if (flightTimeElapsed >= flightDurationRequired) {
                    // 飛行時間達成したら着陸フェーズへ移行
                    gameActive = false; // 一時停止
                    showLandingClearance = true;
                    landingClearanceStartTime = Date.now();
                    currentPhase = GAME_PHASE.LANDING_CLEARANCE;
                    timerDisplay.style.display = 'none'; // タイマー非表示
                    // 他の飛行機をクリア
                    otherPlanes.length = 0;
                    otherPlaneSpawnTimer = 0;
                    clouds.length = 0; // 雲もリセットして着陸フェーズへ備える
                    showControls(); // 着陸フェーズ移行時に操作ボタンを表示
                }
            }
            
            // キーボードとタッチボタンの入力を統合
            if (keys.ArrowRight || keys.RightButton) {
                planeSpeedX += acceleration;
                if (planeSpeedX > maxGroundSpeed) planeSpeedX = maxGroundSpeed;
            } else if (keys.ArrowLeft || keys.LeftButton) {
                planeSpeedX -= acceleration;
                if (planeSpeedX < -maxGroundSpeed) planeSpeedX = -maxGroundSpeed;
            } else {
                if (!isInAir) { // 地上にいる時のみ減速
                    if (planeSpeedX > 0) {
                        planeSpeedX -= acceleration / 2;
                        if (planeSpeedX < 0) planeSpeedX = 0;
                    } else if (planeSpeedX < 0) {
                        planeSpeedX += acceleration / 2;
                        if (planeSpeedX > 0) planeSpeedX = 0;
                    }
                }
            }

            if (!isInAir) {
                // 地上での操作
                planeX += planeSpeedX;

                // 離陸判定 (FLIGHTフェーズの時のみ離陸可能)
                if ((keys.ArrowUp || keys.UpButton) && planeSpeedX > 3 && currentPhase === GAME_PHASE.FLIGHT) {
                    planeSpeedY = lift;
                    isInAir = true;
                }

                // 地面に接している状態に固定
                planeY = initialCanvasHeight - 50;
                
                if (planeX < planeWidth / 2) {
                    planeX = planeWidth / 2;
                    planeSpeedX = 0;
                }
                if (planeX > initialCanvasWidth - planeWidth / 2) {
                    planeX = initialCanvasWidth - planeWidth / 2;
                    planeSpeedX = 0;
                }

            } else { // 空中での操作
                if (keys.ArrowUp || keys.UpButton) {
                    planeSpeedY = Math.max(-maxAirSpeedY, planeSpeedY + lift);
                }
                if (keys.ArrowDown || keys.DownButton) {
                    planeSpeedY = Math.min(maxAirSpeedY, planeSpeedY + gravity);
                }

                planeSpeedY += gravity;
                planeY += planeSpeedY;
                planeX += planeSpeedX * 0.5; // 空中では水平速度を少し維持

                if (planeY < planeHeight / 2) { // 画面上端にぶつからないように
                    planeY = planeHeight / 2;
                    planeSpeedY = 0;
                }
                if (planeX < planeWidth / 2) planeX = planeWidth / 2;
                if (planeX > initialCanvasWidth - planeWidth / 2) planeX = initialCanvasWidth - planeWidth / 2;
                
                // 着陸判定: LANDINGフェーズ中
                const currentScaledTargetLandingAltitude = targetLandingAltitude;
                const currentScaledLandingAltitudeTolerance = landingAltitudeTolerance * (canvas.height / initialCanvasHeight);

                if (currentPhase === GAME_PHASE.LANDING && planeY * (canvas.height / initialCanvasHeight) >= currentScaledTargetLandingAltitude - currentScaledLandingAltitudeTolerance) {
                    let failureReason = [];

                    // 高度チェック
                    if (planeY * (canvas.height / initialCanvasHeight) > currentScaledTargetLandingAltitude + currentScaledLandingAltitudeTolerance || planeY * (canvas.height / initialCanvasHeight) < currentScaledTargetLandingAltitude - currentScaledLandingAltitudeTolerance) {
                         failureReason.push('着地位置が滑走路から離れすぎました！');
                    }

                    // 垂直速度チェック
                    if (Math.abs(planeSpeedY) >= targetVerticalSpeed) {
                        failureReason.push(`接地速度(${Math.abs(planeSpeedY).toFixed(1)})が速すぎます！もう少し優しく着地してください。`);
                    }

                    if (failureReason.length === 0) {
                        isInAir = false;
                        planeSpeedY = 0;
                        planeY = initialCanvasHeight - 50;
                        gameClear('着陸成功！ゲームクリア！');
                        return;
                    } else {
                        // 失敗した場合、具体的な理由を表示
                        gameOver('着陸失敗！' + failureReason.join(' '));
                        return;
                    }
                } else if (planeY * (canvas.height / initialCanvasHeight) > canvas.height + planeHeight * (canvas.height / initialCanvasHeight)) {
                    // 画面下まで落ちたら無条件でゲームオーバー（高度が足りずに墜落）
                    gameOver('着陸に失敗しました！高度が低すぎました。');
                    return;
                }

                // 雲の生成と移動
                if (planeY < airportDisappearAltitude && (currentPhase === GAME_PHASE.FLIGHT || currentPhase === GAME_PHASE.LANDING_CLEARANCE)) {
                    if (clouds.length < maxClouds && Math.random() < 0.01) {
                        clouds.push({
                            x: initialCanvasWidth,
                            y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50, /* 雲のY座標を調整 */
                            size: Math.random() * 50 + 30
                        });
                    }
                }
                for (let i = clouds.length - 1; i >= 0; i--) {
                    clouds[i].x -= cloudSpeed;
                    if (clouds[i].x < -clouds[i].size) {
                        clouds.splice(i, 1);
                    }
                }

                // 他の飛行機の生成と移動 (FLIGHTフェーズ中のみ)
                if (currentPhase === GAME_PHASE.FLIGHT) {
                    otherPlaneSpawnTimer++;
                    if (otherPlanes.length < maxOtherPlanes && otherPlaneSpawnTimer >= otherPlaneSpawnInterval) {
                        if (Math.random() < 0.5) { // 左から出現
                            otherPlanes.push({
                                x: -planeWidth,
                                y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50,
                                speed: Math.random() * (otherPlaneSpeedMax - otherPlaneSpeedMin) + otherPlaneSpeedMin,
                                direction: 1
                            });
                        } else { // 右から出現
                            otherPlanes.push({
                                x: initialCanvasWidth + planeWidth,
                                y: Math.random() * (initialCanvasHeight - runwayHeight - 100) + 50,
                                speed: Math.random() * (otherPlaneSpeedMax - otherPlaneSpeedMin) + otherPlaneSpeedMin,
                                direction: -1
                            });
                        }
                        otherPlaneSpawnTimer = 0;
                    }

                    for (let i = 0; i < otherPlanes.length; i++) {
                        const op = otherPlanes[i];
                        op.x += op.speed * op.direction;
                        if (op.direction === 1 && op.x > initialCanvasWidth + planeWidth * 2 ||
                            op.direction === -1 && op.x < -planeWidth * 2) {
                            otherPlanes.splice(i, 1);
                            i--;
                        }
                    }

                    // 衝突判定
                    for (let i = 0; i < otherPlanes.length; i++) {
                        const op = otherPlanes[i];
                        if (
                            planeX - planeWidth / 2 < op.x + planeWidth / 2 &&
                            planeX + planeWidth / 2 > op.x - planeWidth / 2 &&
                            planeY - planeHeight / 2 < op.y + planeHeight / 2 &&
                            planeY + planeHeight / 2 > op.y - planeHeight / 2
                        ) {
                            gameOver('他の飛行機と衝突！墜落しました！');
                            return;
                        }
                    }
                }
            }
        }

        /**
         * ゲーム要素を描画する関数
         */
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 画面をクリア

            // ルール説明中はゲーム要素を描画しない
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            const scaleX = canvas.width / initialCanvasWidth;
            const scaleY = canvas.height / initialCanvasHeight;

            // 雲を描画 (飛行機の高度によって表示)
            if (planeY < airportDisappearAltitude && (currentPhase === GAME_PHASE.FLIGHT || currentPhase === GAME_PHASE.LANDING_CLEARANCE)) {
                for (const cloud of clouds) {
                    drawCloud(cloud.x, cloud.y, cloud.size);
                }
            }

            // 空港の描画 (特定のフェーズと高度でのみ表示)
            const isAirportVisible = (currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || 
                                      currentPhase === GAME_PHASE.LANDING_CLEARANCE || 
                                      (currentPhase === GAME_PHASE.FLIGHT && planeY > airportDisappearAltitude) ||
                                      (currentPhase === GAME_PHASE.LANDING && planeY > airportReappearAltitude));

            if (isAirportVisible) {
                drawRunway();
                drawAirport();
            }
            
            drawPlane(planeX, planeY, planeWidth, planeHeight); // プレイヤーの飛行機

            // 他の飛行機を描画
            for (const op of otherPlanes) {
                drawPlane(op.x, op.y, planeWidth * 0.8, planeHeight * 0.8, '#008000'); // 他の飛行機は少し小さく緑色
            }

            // 離陸許可メッセージ
            if (showTakeOffClearance && currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE) {
                ctx.font = `${30 * scaleY}px Arial Black`;
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText("Cleared for take off", controlTowerX, controlTowerY - 30 * scaleY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * Math.min(scaleX, scaleY);
                ctx.strokeText("Cleared for take off", controlTowerX, controlTowerY - 30 * scaleY);
            }

            // 着陸許可メッセージ
            if (showLandingClearance && currentPhase === GAME_PHASE.LANDING_CLEARANCE) {
                ctx.font = `${30 * scaleY}px Arial Black`;
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.fillText("Cleared to land", controlTowerX, controlTowerY - 30 * scaleY);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * Math.min(scaleX, scaleY);
                ctx.strokeText("Cleared to land", controlTowerX, controlTowerY - 30 * scaleY);
            }

            // 着陸ガイドの表示
            if (currentPhase === GAME_PHASE.LANDING && gameActive) {
                landingGuide.style.display = 'block';

                const currentAltitude = Math.floor(initialCanvasHeight - planeY);
                const goalAltitude = Math.floor(initialCanvasHeight - (initialCanvasHeight - runwayHeight) + planeHeight / 2);

                const currentVspeed = (planeSpeedY * 10).toFixed(1);
                const currentHspeed = (planeSpeedX * 10).toFixed(1);

                let guideText = '--- 着陸ガイド ---\n';
                
                guideText += `高度: ${currentAltitude}m (目標: ${goalAltitude}m ±${landingAltitudeTolerance}m)\n`;
                if (currentAltitude > goalAltitude + landingAltitudeTolerance) {
                    guideText += '  ↑ 高すぎます！もっと下降を。\n';
                } else if (currentAltitude < goalAltitude - landingAltitudeTolerance) {
                    guideText += '  ↓ 低すぎます！少し上昇を。\n';
                } else {
                    guideText += '  ◎ 高度良好\n';
                }

                guideText += `垂直速度: ${currentVspeed}km/h (目標: <${(targetVerticalSpeed * 10).toFixed(1)}km/h)\n`;
                if (Math.abs(planeSpeedY) >= targetVerticalSpeed) {
                    guideText += '  ↓ 垂直速度が速すぎます！優しく。\n';
                } else {
                    guideText += '  ◎ 垂直速度良好\n';
                }

                guideText += `水平速度: ${currentHspeed}km/h\n`; 

                landingGuide.innerText = guideText;
            } else {
                landingGuide.style.display = 'none';
            }
        }

        /**
         * ゲームオーバー処理
         */
        function gameOver(message) {
            gameActive = false;
            currentPhase = GAME_PHASE.GAME_OVER;
            gameStatusMessage.innerText = message;
            messageOverlay.style.display = 'flex';
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';
            showRulesButton.style.display = 'none'; // ゲームオーバー時はルールボタンを非表示
            if (synth.speaking) {
                synth.cancel();
            }
            hideControls(); // 操作ボタンを隠す
            canvas.style.display = 'none'; // ゲームオーバー時もキャンバスを非表示
        }

        /**
         * ゲームクリア処理
         */
        function gameClear(message) {
            gameActive = false;
            currentPhase = GAME_PHASE.GAME_CLEAR;
            gameStatusMessage.innerText = message;
            messageOverlay.style.display = 'flex';
            timerDisplay.style.display = 'none';
            landingGuide.style.display = 'none';
            showRulesButton.style.display = 'none'; // ゲームクリア時はルールボタンを非表示
            if (synth.speaking) {
                synth.cancel();
            }
            hideControls(); // 操作ボタンを隠す
            canvas.style.display = 'none'; // ゲームクリア時もキャンバスを非表示
        }

        /**
         * ゲームループ
         */
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // キーボードイベントリスナー
        document.addEventListener('keydown', (e) => {
            // ルール説明中はキーボード操作を無効化
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) {
                return;
            }

            if (!gameActive && e.key !== 'Space' && currentPhase !== GAME_PHASE.TAKEOFF_CLEARANCE && currentPhase !== GAME_PHASE.LANDING_CLEARANCE) return;

            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        // タッチボタンのイベントリスナー
        function setupTouchButton(buttonElement, keyName) {
            buttonElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // ルール説明中はタッチボタン操作を無効化
                if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
                if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys[keyName] = true;
            });
            buttonElement.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[keyName] = false;
            });
            buttonElement.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys[keyName] = false;
            });
        }

        setupTouchButton(upButton, 'UpButton');
        setupTouchButton(downButton, 'DownButton');
        setupTouchButton(leftButton, 'LeftButton');
        setupTouchButton(rightButton, 'RightButton');

        // 仮想タッチエリアのイベントリスナー
        leftTouchArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // ルール説明中はタッチエリア操作を無効化
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
            if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys.LeftButton = true;
        });
        leftTouchArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.LeftButton = false;
        });
        leftTouchArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys.LeftButton = false;
        });

        rightTouchArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // ルール説明中はタッチエリア操作を無効化
            if (currentPhase === GAME_PHASE.RULES_EXPLANATION) return;
            if (gameActive || currentPhase === GAME_PHASE.TAKEOFF_CLEARANCE || currentPhase === GAME_PHASE.LANDING_CLEARANCE) keys.RightButton = true;
        });
        rightTouchArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.RightButton = false;
        });
        rightTouchArea.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            keys.RightButton = false;
        });


        // リトライボタンのイベントリスナー
        restartButton.addEventListener('click', resetGame);

        // ゲームスタートボタンのイベントリスナー
        startGameButton.addEventListener('click', () => {
            hideRulesExplanation(); // ルール説明を隠す
            // 最初のフェーズ（離陸許可）を開始
            currentPhase = GAME_PHASE.TAKEOFF_CLEARANCE;
            takeOffClearanceStartTime = Date.now();
            // 操作ボタンを表示（離陸前から表示）
            showControls();
            showRulesButton.style.display = 'block'; // ゲーム開始後にルール表示ボタンを表示
        });

        // ルール表示ボタンのイベントリスナー
        showRulesButton.addEventListener('click', showRulesExplanation);


        // ウィンドウリサイズイベント
        window.addEventListener('resize', resizeCanvas);

        // ゲーム開始
        resizeCanvas(); // 初期ロード時にもキャンバスサイズを調整
        resetGame(); // 初期化時にルール説明を表示
        gameLoop();
    </script>
</body>
</html>